# Database
Use SQLite as database engine

## Schemas

**Version : 2.1**

### quottery_info
This table holds information about bets. Each column represents a property of a bet, and each row corresponds to an individual bet.

**Table colummns**: write as line for better visualization
```
bet_id                = <Unique identifier for the bet>
no_options            = <Number of options available for the bet>
creator               = <The creator of the bet>
bet_desc              = <Description of the bet>
option_desc           = <Array of descriptions for each option>
current_bet_state     = <Array of states for each option>
max_slot_per_option   = <Maximum number of slots available per option>
amount_per_bet_slot   = <Amount of qus per bet slot>
open_date             = <Date when the bet opens (YY-MM-DD)>
close_date            = <Date when the bet closes (YY-MM-DD)>
end_date              = <Date when the bet ends (YY-MM-DD)>
open_time             = <Time when the bet opens (HH:MM:SS)>
close_time            = <Time when the bet closes (HH:MM:SS)>
end_time              = <Time when the bet ends (HH:MM:SS)>
result                = <Outcome of the bet>
no_ops                = <Number of oracle providers>
oracle_id             = <Array of oracle IDs>
oracle_fee            = <Array of fees for each oracle>
oracle_vote           = <Array of oracle votes for the options>
status                = <Current status of the bet>
current_num_selection = <Placeholder for future use>
current_total_qus     = <Total of qus>
betting_odds          = <Array of betting odds for each option>
```

### bet_options_detail

This table details the selections made for bet options, indicating how many slots a specific user has bet on an option. Each row is linked to a bet_id and an option_id.

**Table colummns**: write as line for better visualization
```
bet_id      = < Identifier for the bet>
option_id   = <Identifier for the option within the bet>
user_slots  = <Dict of user IDs to the number of slots they have bet (e.g., {"user_id_0": number_of_slots, ...})>

```

### node_basic_info
This table contains basic information about the quoterry node. It is expected to have only one row.

**Table colummns**: write as line for better visualization
```
ip                          = <IP address of the node>
port                        = <Port number used by the node>
fee_per_slot_per_hour       = <Fee charged per slot per hour>
min_amount_per_slot         = <Minimum amount required per slot>
game_operator_fee           = <Fee collected by the game operator>
shareholders_fee            = <Fee distributed to shareholders>
burn_fee                    = <Fee that is burned>
num_issued_bet              = <Number of bets issued.>
moneyflow                   = <Total money flow>
moneyflow_through_issuebet  = <Money flow through bet issuance>
moneyflow_through_joinbet   = <Money flow through joining a bet>
moneyflow_through_finalize  = <Money flow through finalizing a bet>
shareholders_earned_amount  = <Amount earned by shareholders>
shareholders_paid_amount    = <Amount paid to shareholders>
winners_earned_amount       = <Amount earned by winners>
distributed_amount          = <Total distributed amount>
burned_amount               = <Total burned amount.>
game_operator_id            = <dentifier for the game operator>
```

### tick_info
This table tracks the tick number of data contained in the database. It is expected to have only one row.

**Table colummns**: write as line for better visualization
```
tick_number = <The current tick number>

(The following columns are placeholders for future use and currently unused: epoch, tick_duration, number_of_aligned_votes, number_of_misaligned_votes, initial_tick.)
```

### version
This table stores the version of the database and is expected to have only one row.
**Table colummns**: write as line for better visualization
```
version_info = <Information about the current database version>
```
### user_bet_info
(Currently unused placeholder for future data.)

## Database updater (db_updater.py)

### Operation
The script is designed to make requests to the node at specified intervals. It can accept configuration parameters either from environment variables or command-line arguments, with the latter taking precedence.

### Configuration
**Environment Variables**
These are preferred when launching with Docker Compose:
- NODE_IP: The IP address of the node to connect to for database updates.
- NODE_PORT: The port number of the node.
- DATABASE_PATH: The file path to the SQLite database.

**Command-Line Arguments**
These override environment variables if provided:
- -nodeip: The IP address of the node to connect to for database updates.
- -nodeport: The port number of the node.
- -dbpath: The file path to the SQLite database.

Usage
To run the updater with environment variables, set them in your environment or Docker Compose file:

```shell
# Run in command line
export NODE_IP=192.168.1.1
export NODE_PORT=5000
export DATABASE_PATH='/path/to/database.db'
python3 db_updater.py
```

```yaml
# Launch in Docker compose
services:
  db-updater:
    # Change the path to suitable Docker image
    image: "ghcr.io/icyblob/flask-app:latest"
    volumes:
        # Mount the current folder as folder for saving database. Make sure you mount the same folder with flask-app
      - .:/database
      - /etc/localtime:/etc/localtime:ro
      - /etc/timezone:/etc/timezone:ro
    environment:
      - NODE_IP=5.199.134.150 
      - NODE_PORT=31844
      - *common-env
    command: ["python3", "db_updater.py"]
    restart: always
```

To run the updater with command-line arguments:
```shell
python db_updater.py --nodeip '192.168.1.1' --nodeport '8080' --dbpath '/path/to/database.db'
```

Ensure that the quottery_cpp_wrapper is accessible and that the provided IP and port are correct for successful data synchronization.

### Functions

#### update_database_with_bets

This function serves as the core component responsible for synchronizing bet data between the node and the database. It performs two primary tasks:

- Data Retrieval: It connects to the node to retrieve the latest bet data, utilizing the quottery_cpp_wrapper to ensure accurate and efficient communication.

- Database Update: After fetching the data, the function proceeds to update the database with the new bet information, ensuring that the records are current and reflect the latest state of bets.

## Quoterry cpp wrapper (quottery_cpp_wrapper.py)
The quottery_cpp_wrapper class contain the wrapper for calling the C++ function for requesting information from node


### quottery_cpp_wrapper.__init__(self, libs, nodeIP, port, logName='')
#### Args:
- libs (str): The full path to quottery_cpp library 
- nodeIP (str): The IP of the node
- port (int): The port of the node
- logName (str, optional): The name of the logging, default is empty

### quottery_cpp_wrapper.get_all_bets(self)
Gets the information of all bet that respond from node

#### Returns:
- sts (int): status of request. 0 is success, otherwise is failure
- list: list of dictionary that contain information about all bet information. If failure, it is empty

### quottery_cpp_wrapper. get_bet_info(self, betId)
Gets the information of a specific bet

Args:
  betId (int): The ID of the bet

Returns:
  sts (int): status of request. 0 is success, otherwise is failure
  dict: a dictionary that contain information about bet information. If failure, it is empty

### quottery_cpp_wrapper. get_bet_option_detail(self, betID, betOption)
Gets the detail of a specific bet and bet option

#### Args:
- betId (int): The ID of the bet
- betOption (int): The option ID of this bet

#### Returns:
- sts (int): status of request. 0 is success, otherwise is failure
- dict: a dictionary that contain user id and the number of slots of this bet option. If failure, it is empty

### quottery_cpp_wrapper. get_qtry_basic_info(self)

Gets the quottery basic information

#### Returns:
- sts (int): status of request. 0 is success, otherwise is failure
- dict: a dictionary that contain information about quottery basic information. If failure, it is empty